/**
 * QR Code Generator for Qopy
 * Client-side QR code generation compatible with CSP restrictions
 * Based on qrcode.js library adapted for CSP compliance
 */

(function(global) {
    'use strict';

    // QR Code Reed-Solomon error correction tables
    const QR_RS_BLOCK_TABLE = [
        [1, 26, 19],
        [1, 26, 16],
        [1, 26, 13],
        [1, 26, 9],
        [1, 44, 34],
        [1, 44, 28],
        [1, 44, 22],
        [1, 44, 16],
        [1, 70, 55],
        [1, 70, 44],
        [2, 35, 17],
        [2, 35, 13],
        [1, 100, 80],
        [2, 50, 32],
        [2, 50, 24],
        [4, 25, 9],
        [1, 134, 108],
        [2, 67, 43],
        [2, 33, 15, 2, 34, 16],
        [2, 33, 11, 2, 34, 12],
        [2, 86, 68],
        [4, 43, 27],
        [4, 43, 19],
        [4, 43, 15],
        [2, 98, 78],
        [4, 49, 31],
        [2, 32, 14, 4, 33, 15],
        [4, 39, 13, 1, 40, 14],
        [2, 121, 97],
        [2, 60, 38, 2, 61, 39],
        [4, 40, 18, 2, 41, 19],
        [4, 40, 14, 2, 41, 15],
        [2, 146, 116],
        [3, 58, 36, 2, 59, 37],
        [4, 36, 16, 4, 37, 17],
        [4, 36, 12, 4, 37, 13],
        [2, 86, 68, 2, 87, 69],
        [4, 69, 43, 1, 70, 44],
        [6, 43, 19, 2, 44, 20],
        [6, 43, 15, 2, 44, 16],
        [4, 101, 81],
        [1, 80, 50, 4, 81, 51],
        [4, 50, 22, 4, 51, 23],
        [3, 36, 12, 8, 37, 13],
        [2, 116, 92, 2, 117, 93],
        [6, 58, 36, 2, 59, 37],
        [4, 46, 20, 6, 47, 21],
        [7, 42, 14, 4, 43, 15],
        [4, 133, 107],
        [8, 59, 37, 1, 60, 38],
        [8, 44, 20, 4, 45, 21],
        [12, 33, 11, 4, 34, 12],
        [3, 145, 115, 1, 146, 116],
        [4, 64, 40, 5, 65, 41],
        [11, 36, 16, 5, 37, 17],
        [11, 36, 12, 5, 37, 13],
        [5, 109, 87, 1, 110, 88],
        [5, 65, 41, 5, 66, 42],
        [5, 54, 24, 7, 55, 25],
        [11, 36, 12, 7, 37, 13],
        [5, 122, 98, 1, 123, 99],
        [7, 73, 45, 3, 74, 46],
        [15, 43, 19, 2, 44, 20],
        [3, 45, 15, 13, 46, 16],
        [1, 135, 107, 5, 136, 108],
        [10, 74, 46, 1, 75, 47],
        [1, 50, 22, 15, 51, 23],
        [2, 42, 14, 17, 43, 15],
        [5, 150, 120, 1, 151, 121],
        [9, 69, 43, 4, 70, 44],
        [17, 50, 22, 1, 51, 23],
        [2, 42, 14, 19, 43, 15],
        [3, 141, 113, 4, 142, 114],
        [3, 70, 44, 11, 71, 45],
        [17, 47, 21, 4, 48, 22],
        [9, 39, 13, 16, 40, 14],
        [3, 135, 107, 5, 136, 108],
        [3, 67, 41, 13, 68, 42],
        [15, 54, 24, 5, 55, 25],
        [15, 43, 15, 10, 44, 16],
        [4, 144, 116, 4, 145, 117],
        [17, 68, 42],
        [17, 50, 22, 6, 51, 23],
        [19, 46, 16, 6, 47, 17],
        [2, 139, 111, 7, 140, 112],
        [17, 74, 46],
        [7, 54, 24, 16, 55, 25],
        [34, 37, 13],
        [4, 151, 121, 5, 152, 122],
        [4, 75, 47, 14, 76, 48],
        [11, 54, 24, 14, 55, 25],
        [16, 45, 15, 14, 46, 16],
        [6, 147, 117, 4, 148, 118],
        [6, 73, 45, 14, 74, 46],
        [11, 54, 24, 16, 55, 25],
        [30, 46, 16, 2, 47, 17],
        [8, 132, 106, 4, 133, 107],
        [8, 75, 47, 13, 76, 48],
        [7, 54, 24, 22, 55, 25],
        [22, 45, 15, 13, 46, 16],
        [10, 142, 114, 2, 143, 115],
        [19, 74, 46, 4, 75, 47],
        [28, 50, 22, 6, 51, 23],
        [33, 46, 16, 4, 47, 17],
        [8, 152, 122, 4, 153, 123],
        [22, 73, 45, 3, 74, 46],
        [8, 53, 23, 26, 54, 24],
        [12, 45, 15, 28, 46, 16],
        [3, 147, 117, 10, 148, 118],
        [3, 73, 45, 23, 74, 46],
        [4, 54, 24, 31, 55, 25],
        [11, 45, 15, 31, 46, 16],
        [7, 146, 116, 7, 147, 117],
        [21, 73, 45, 7, 74, 46],
        [1, 53, 23, 37, 54, 24],
        [19, 45, 15, 26, 46, 16],
        [5, 145, 115, 10, 146, 116],
        [19, 75, 47, 10, 76, 48],
        [15, 54, 24, 25, 55, 25],
        [23, 45, 15, 25, 46, 16],
        [13, 145, 115, 3, 146, 116],
        [2, 74, 46, 29, 75, 47],
        [42, 54, 24, 1, 55, 25],
        [23, 45, 15, 28, 46, 16],
        [17, 145, 115],
        [10, 74, 46, 23, 75, 47],
        [10, 54, 24, 35, 55, 25],
        [19, 45, 15, 35, 46, 16],
        [17, 145, 115, 1, 146, 116],
        [14, 74, 46, 21, 75, 47],
        [29, 54, 24, 19, 55, 25],
        [11, 45, 15, 46, 46, 16],
        [13, 145, 115, 6, 146, 116],
        [14, 74, 46, 23, 75, 47],
        [44, 54, 24, 7, 55, 25],
        [59, 46, 16, 1, 47, 17],
        [12, 151, 121, 7, 152, 122],
        [12, 75, 47, 26, 76, 48],
        [39, 54, 24, 14, 55, 25],
        [22, 45, 15, 41, 46, 16],
        [6, 151, 121, 14, 152, 122],
        [6, 75, 47, 34, 76, 48],
        [46, 54, 24, 10, 55, 25],
        [2, 45, 15, 64, 46, 16],
        [17, 152, 122, 4, 153, 123],
        [29, 74, 46, 14, 75, 47],
        [49, 54, 24, 10, 55, 25],
        [24, 45, 15, 46, 46, 16],
        [4, 152, 122, 18, 153, 123],
        [13, 74, 46, 32, 75, 47],
        [48, 54, 24, 14, 55, 25],
        [42, 45, 15, 32, 46, 16],
        [20, 147, 117, 4, 148, 118],
        [40, 75, 47, 7, 76, 48],
        [43, 54, 24, 22, 55, 25],
        [10, 45, 15, 67, 46, 16],
        [19, 148, 118, 6, 149, 119],
        [18, 75, 47, 31, 76, 48],
        [34, 54, 24, 34, 55, 25],
        [20, 45, 15, 61, 46, 16]
    ];

    // QR Code generator
    function QRCode() {
        this.size = 200;
        this.margin = 2;
        this.darkColor = '#000000';
        this.lightColor = '#FFFFFF';
    }

    QRCode.prototype.toDataURL = function(text, options) {
        return new Promise((resolve, reject) => {
            try {
                // Create canvas
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Set size
                const size = options?.width || this.size;
                canvas.width = size;
                canvas.height = size;
                
                // Fill background
                ctx.fillStyle = options?.color?.light || this.lightColor;
                ctx.fillRect(0, 0, size, size);
                
                // Generate QR code pattern
                const qrData = this.generateQRPattern(text);
                const cellSize = Math.floor((size - this.margin * 2) / qrData.length);
                
                // Draw QR code
                ctx.fillStyle = options?.color?.dark || this.darkColor;
                for (let i = 0; i < qrData.length; i++) {
                    for (let j = 0; j < qrData[i].length; j++) {
                        if (qrData[i][j]) {
                            ctx.fillRect(
                                this.margin + j * cellSize,
                                this.margin + i * cellSize,
                                cellSize,
                                cellSize
                            );
                        }
                    }
                }
                
                resolve(canvas.toDataURL());
            } catch (error) {
                reject(error);
            }
        });
    };

    QRCode.prototype.generateQRPattern = function(text) {
        // Convert text to binary data
        const data = this.encodeText(text);
        
        // Determine QR code version based on data length
        const version = this.getVersion(data.length);
        const size = version * 4 + 17;
        
        // Create QR code matrix
        const matrix = Array(size).fill().map(() => Array(size).fill(false));
        
        // Add finder patterns
        this.addFinderPattern(matrix, 0, 0);
        this.addFinderPattern(matrix, size - 7, 0);
        this.addFinderPattern(matrix, 0, size - 7);
        
        // Add alignment patterns if needed
        if (version > 1) {
            const alignmentPositions = this.getAlignmentPositions(version);
            for (let i = 0; i < alignmentPositions.length; i++) {
                for (let j = 0; j < alignmentPositions.length; j++) {
                    const row = alignmentPositions[i];
                    const col = alignmentPositions[j];
                    if (!this.isInFinderPattern(row, col, size)) {
                        this.addAlignmentPattern(matrix, row - 2, col - 2);
                    }
                }
            }
        }
        
        // Add timing patterns
        for (let i = 8; i < size - 8; i++) {
            if (!matrix[6][i]) matrix[6][i] = i % 2 === 0;
            if (!matrix[i][6]) matrix[i][6] = i % 2 === 0;
        }
        
        // Add dark module
        matrix[size - 8][8] = true;
        
        // Add data and error correction
        const encodedData = this.addErrorCorrection(data, version);
        this.placeData(matrix, encodedData, size);
        
        // Apply masking
        const maskedMatrix = this.applyMasking(matrix, size);
        
        return maskedMatrix;
    };

    QRCode.prototype.encodeText = function(text) {
        const data = [];
        
        // Add mode indicator (8-bit byte mode)
        data.push(0, 1, 0, 0);
        
        // Add character count indicator
        const length = text.length;
        const lengthBits = this.getCharacterCountBits(length);
        for (let i = lengthBits.length - 1; i >= 0; i--) {
            data.push(lengthBits[i]);
        }
        
        // Add data bits
        for (let i = 0; i < text.length; i++) {
            const charCode = text.charCodeAt(i);
            for (let j = 7; j >= 0; j--) {
                data.push((charCode >> j) & 1);
            }
        }
        
        // Add padding
        const capacity = this.getDataCapacity(length);
        while (data.length < capacity) {
            data.push(0);
        }
        
        return data;
    };

    QRCode.prototype.getVersion = function(dataLength) {
        // Simple version selection - for production use a more sophisticated algorithm
        if (dataLength <= 25) return 1;
        if (dataLength <= 47) return 2;
        if (dataLength <= 77) return 3;
        return 4;
    };

    QRCode.prototype.getCharacterCountBits = function(length) {
        const bits = [];
        for (let i = 7; i >= 0; i--) {
            bits.push((length >> i) & 1);
        }
        return bits;
    };

    QRCode.prototype.getDataCapacity = function(length) {
        // Simplified capacity calculation
        return Math.floor((length + 8) * 8 * 1.1); // Rough estimate with 10% overhead
    };

    QRCode.prototype.addErrorCorrection = function(data, version) {
        // Simplified error correction - just return the data
        // In a real implementation, this would add Reed-Solomon error correction
        return data;
    };

    QRCode.prototype.placeData = function(matrix, data, size) {
        let dataIndex = 0;
        let direction = -1; // Start going up
        let col = size - 1;
        
        for (let row = size - 1; row >= 0; row -= 2) {
            if (row === 6) row--; // Skip timing pattern
            
            for (let c = 0; c < 2; c++) {
                const currentCol = col - c;
                if (currentCol < 0) break;
                
                for (let r = 0; r < 2; r++) {
                    const currentRow = row - r;
                    if (currentRow < 0) break;
                    
                    if (!this.isReserved(matrix, currentRow, currentCol)) {
                        if (dataIndex < data.length) {
                            matrix[currentRow][currentCol] = data[dataIndex] === 1;
                            dataIndex++;
                        }
                    }
                }
            }
            
            col += direction;
            if (col < 0 || col >= size) {
                direction = -direction;
                col += direction;
            }
        }
    };

    QRCode.prototype.applyMasking = function(matrix, size) {
        // Apply mask pattern 0 (XOR with (row + column) % 2)
        const maskedMatrix = Array(size).fill().map(() => Array(size).fill(false));
        
        for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
                const mask = ((i + j) % 2) === 0;
                maskedMatrix[i][j] = matrix[i][j] !== mask;
            }
        }
        
        return maskedMatrix;
    };

    QRCode.prototype.addFinderPattern = function(matrix, row, col) {
        for (let i = 0; i < 7; i++) {
            for (let j = 0; j < 7; j++) {
                if ((i === 0 || i === 6 || j === 0 || j === 6) ||
                    (i >= 2 && i <= 4 && j >= 2 && j <= 4)) {
                    matrix[row + i][col + j] = true;
                }
            }
        }
    };

    QRCode.prototype.addAlignmentPattern = function(matrix, row, col) {
        for (let i = 0; i < 5; i++) {
            for (let j = 0; j < 5; j++) {
                if (i === 0 || i === 4 || j === 0 || j === 4 ||
                    (i === 2 && j === 2)) {
                    matrix[row + i][col + j] = true;
                }
            }
        }
    };

    QRCode.prototype.isInFinderPattern = function(row, col, size) {
        // Check if position is within any finder pattern
        const finderPositions = [
            [0, 0], [size - 7, 0], [0, size - 7]
        ];
        
        for (let [fr, fc] of finderPositions) {
            if (row >= fr && row < fr + 7 && col >= fc && col < fc + 7) {
                return true;
            }
        }
        
        return false;
    };

    QRCode.prototype.isReserved = function(matrix, row, col) {
        return matrix[row][col] !== undefined && matrix[row][col] !== false;
    };

    QRCode.prototype.getAlignmentPositions = function(version) {
        // Simplified alignment position calculation
        if (version === 2) return [6, 18];
        if (version === 3) return [6, 22];
        if (version === 4) return [6, 14, 22, 30];
        return [];
    };

    // Export to global scope
    global.QRCode = QRCode;

})(typeof window !== 'undefined' ? window : this);