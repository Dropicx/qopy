---
description: Qopy project context for efficient AI-assisted development
alwaysApply: true
---

# Qopy AI Programming Context

## Quick Reference

**Stack**: Express.js, PostgreSQL, optional Redis. Client-side AES-256-GCM encryption, zero-knowledge.

**Entry points**:
- `server.js` - Main app (~3.2k lines, migrating to services)
- `public/script.js`, `public/file-upload.js` - Frontend
- `services/` - Business logic (29 services)

**Key files for changes**:
- Routes/endpoints → `server.js`
- Upload logic → `services/FileAssemblyService.js`, `services/UploadValidator.js`
- Access validation → `middleware/accessValidation.js`, `services/AccessValidator.js`
- Encryption → `services/EncryptionService.js` (client does actual crypto)

## Commands

```bash
npm run dev          # Hot reload
npm test             # Jest (unit + integration)
npm run test:unit    # Unit only
npm run test:integration
```

## Architecture Notes

- **Refactored services** (`RefactoredFileUploadManager`, `RefactoredShareEndpoint`): Used by tests/verification scripts only; not wired in `server.js`. Do not assume they're active.
- **Chunk upload**: 5MB chunks, 6MB multer limit. Flow: initiate → chunk → complete.
- **Never log**: plaintext, passwords, URL secrets, decrypted content.
- **Database**: Parameterized queries only. Pool: max 20 prod, 10 dev.

## Spec-First Approach

When implementing features:
1. Check `CLAUDE.md` for architecture and existing services
2. Prefer extending services over adding to `server.js`
3. Add/update tests in `tests/unit/services/` or `tests/integration/`
4. Run `npm test` before committing
